1.	同步代码块，同步方法可以确保以原子的方式执行操作
2.	内存可见性（Memory Visiblility）：确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。
3.	在没有同步的情况下，由于编译器，处理器以及运行时都可能对操作的执行顺序进行意想不到的调整。
4.	最低安全性保证（out-of-thin-airsafety）：当没有同步的情况下读取变量时，可能得到一个失效值，但至少这个值是由之前的某个线程设置的值，而不是随机的值
5.	Java内存模型要求，变量的读取操作和写入操作都必须是原子操作。但对于非volatile的long类型和double类型的变量，JVM允许将64位的读写操作分解为两个32位的操作。
6.	volatile变量是一种稍弱的同步机制，用来确保变量更新操作通知到其他进程
7.	volatile变量仅仅保证可见性，无法保证原子性
8.	发布（Publish）：使对象能够在当前作用域之外的代码中使用：将一个指向对象的引用保存到其他代码能够访问的地方。
9.	逸出（Escape）：当某个不应该发布的对象被发布时，就叫逸出
10.	外部（Alien）方法是指行为并不由类本身规定的方法，当把类的对象传递给外部方法时，就相当于发布了这个对象
11.	Java内部类的实例中隐含的包括了一个外部类的引用，这是由于编译器给内部类的构造函数添加了外部类的引用。所以这就是内部类能够访问外部类的原因
12.	线程封闭技术（Thread confinement）：并不共享数据，将对象封闭在某个线程中
13.	单线程子系统是为了使线程封闭和防止死锁
14.	Ad-hoc线程封闭：封闭线程的职责完全由程序来实现承担，非常脆弱
15.	栈封闭使线程封闭的一种特例，只有通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，他们位于执行线程的栈中，其他线程无法访问到这个栈
16.	在线程内部上下文使用非线程安全的对象，那么该对象仍然是线程安全的，只要不把该对象发布出去
17.	维持线程封闭的规范方法是使用ThreadLocal，可以使线程的某个值与保存值的对象关联起来。ThreadLocal会持有一个临时对象，这个对象会被某个频繁操作。如果希望不要在每次操作都重新分配该临时对象，可以考虑使用ThreadLocal持有。
18.	ThreadLocal每次调用get()方法时，都是调用initialValue来获取初始值，将一个单线程应用程序移植到多线程环境中，通过ThreadLoacal持有可以维持线程安全性
19.	不可变对象（Immutable Object）：在被创建后就不能被修改，固有属性之一就是线程安全性
20.	不可变性的三个条件：对象创建以后状态就不能修改，对象所有域都是final类型，对象是正确创建的（对象的创建期间，this引用没有逸出）
21.	final类型的域是不能被修改的，但如果final域引用的对象是可变的，那么这些被引用的对象是可以修改的。
22.	在Java内存模型中，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时不需要同步
23.	除非需要更高的可见性，否则应该将所有的域声明为私有域
24.	除非需要某个域是可变的，否则应该将其声明为final域
25.	可以使用volatile类型的引用来发布不可变对象，使得满足不变性与可见性来保证线程安全
26.	可变对象必须将通过安全的方式来发布，发布和使用该对象的线程都必须使用同步
27.	对象的引用以及对象的状态必须同时对其他线程可见：在静态初试化函数中初始化一个对象引用，将对象引用保存在volatile类型的域或者AtomicReference对象中，将对象的引用保存到某个正确构造对象放入final类型域中，将对象的引用保存到由锁保护的域中
28.	事实不可变对象（Effectively Immutable Object）：技术来讲是可变的，但其状态在发布之后不会再改变
29.	当发布一个对象时，必须明确的说明对象的访问方式。线程封闭，只读共享，线程安全共享（内部实现同步），保护对象
