同步容器类包括Vector与Hashtable，还有Collections。synchronizedXXX等
将他们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能够访问容器的状态
同步容器类是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作包括：迭代（反复访问元素，直到遍历完容器所有元素），跳转（通过指定顺序找到当前元素的下一个元素），条件运算
同步容器类在面对并发修改时，表现出及时失败（fail-fast），当发现容器迭代的过程中被修改时，会抛出一个ConcurrentModificationException
如果不希望在迭代的时候对容器进行加锁，可以使用克隆容器，在副本上进行迭代
使用并发容器类来改进同步容器类，可以极大的提高伸缩性并降低风险
Queue与BlockedQueue的区别，增加了可阻塞的插入和获取操作，如果队列为空，获取元素的操作会一直阻塞，如果队列已满，插入元素的操作会一直阻塞
同步容器在执行每一个操作期间都获得一个锁，如果在遍历操作中查找某个特定对象时，可能要在每个元素上调用equal，会花费很长时间，其他线程在这段时间中不能访问该容器
并发容器并没有在每个方法在同一个锁进行同步，使用了粒度更细的加锁机制来实现更大程度的共享，称为分段锁。任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map，一定数量的写入线程可以并发的修改Map
并发容器类提供的迭代器不会抛出并发修改异常，所以不会在迭代过程中对容器加锁。并发容器类返回的迭代器具有“弱一致性”（Weakly Consistent），可以容忍并发的修改，创建迭代器时会遍历已有的元素，并可以（不保证）在迭代器被构造后将修改返回
并发容器中的size（）isEmpty()返回结果时可能已经过期了，是一个近似值而不是精确值，这些操作在并发环境的用处很小，因为返回值不断在变化
并发需求更重要的操作有get()，put(),containKeys(),remove()
写入时复制（Copy-On-Write）：只要正确的发布一个事实不可变的对象，那么访问该对象时不需要再需要进一步的同步。每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。
