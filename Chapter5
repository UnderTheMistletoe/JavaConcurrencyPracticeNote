同步容器类包括Vector与Hashtable，还有Collections。synchronizedXXX等
将他们的状态封装起来，并对每个公有方法进行同步，使得每次只有一个线程能够访问容器的状态
同步容器类是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作包括：迭代（反复访问元素，直到遍历完容器所有元素），跳转（通过指定顺序找到当前元素的下一个元素），条件运算
同步容器类在面对并发修改时，表现出及时失败（fail-fast），当发现容器迭代的过程中被修改时，会抛出一个ConcurrentModificationException
如果不希望在迭代的时候对容器进行加锁，可以使用克隆容器，在副本上进行迭代
使用并发容器类来改进同步容器类，可以极大的提高伸缩性并降低风险
Queue与BlockedQueue的区别，增加了可阻塞的插入和获取操作，如果队列为空，获取元素的操作会一直阻塞，如果队列已满，插入元素的操作会一直阻塞
同步容器在执行每一个操作期间都获得一个锁，如果在遍历操作中查找某个特定对象时，可能要在每个元素上调用equal，会花费很长时间，其他线程在这段时间中不能访问该容器
并发容器并没有在每个方法在同一个锁进行同步，使用了粒度更细的加锁机制来实现更大程度的共享，称为分段锁。任意数量的读取线程可以并发的访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map，一定数量的写入线程可以并发的修改Map
