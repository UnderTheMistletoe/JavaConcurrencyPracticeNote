1.  设计线程安全的类三个要素：找出构成线程安全状态的所有变量，找出约束状态条件的不变性条件，建立状态对象状态的并发访问管理策略
2.  对于含有n个基本类型域的对象，其状态就是这些域构成的n元组。如果对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。
3.  类中定义了一些不可变条件，用于判断状态是有效的还是无效的
4.  后验条件来判断状态迁移是否是有效的
5.  先验条件来判断在当前状态下是否能进行操作
6.  单线程程序中，如果某个操作无法满足先验条件，只能失败。在并发程序中，先验条件可能因为其他线程的执行而变为真，然后可以进行操作
7.  在许多情况下，所有权与封装性总是相互关联的：对象封装他拥有的状态。发布了某个可变对象引用就为共享控制权。
8.  容器类表现出“所以权分离”形式，容器类拥有自身的状态，而客户代码拥有容器中各个对象的状态
9.  “实例封闭机制”将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁（使用private来保证数据不会逸出）
10.  线程安全的容器类采用装饰器模式将容器类封装在一个同步的包装器对象中，包装器类将接口的每个方法都实现为同步方法，然后将调用分发到底层的容器上，只要底层容器被唯一的封装到包装器中，那么他就是线程安全的
11. 如果一个类是由多个独立且线程安全的状态变量组成，并且所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量
12. 如果一个状态变量是线程安全的，而且并没有任何不变性条件来约束它的值，在变量的操作上也不存在不允许的状态转换，那么就可以安全的发布这个状态变量
13. 客户端加锁（类中实例化一个对象）：对于使用的某个对象X的客户端代码，使用X本身用于保护其状态的锁来保护这段客户代码。必须知道对象X使用的是哪一个锁
14. 扩展类然后进行加锁，与客户端加锁一样会破坏封装性
15. 使用组合（Composition）：通过继承接口与实例化对象，将对象的所有操作委托给组合类，客户端并不会直接使用底层对象，通过添加额外的同步来确保线程安全和封装性
